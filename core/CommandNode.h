#pragma once

#include "Node.h"
#include "FileNode.h"
#include "IMonitoredProcess.h"
#include "MemoryLogBook.h"
#include "../xxHash/xxhash.h"

#include <atomic>
#include <unordered_set>

namespace YAM
{
    class GeneratedFileNode;
    class DirectoryNode;
    class FileRepository;
    class SourceFileNode;

    // CommandNode is capable of:
    //    - executing a shell script with a given set of output files.
    //    - detecting which files are accessed during the execution of the script.
    //    - checking that the write-accessed files match the output files.
    //    - registering the detected read-accessed files as input files.
    //    - detecting changes in script, input and/or output files.
    //      Such changes will out-date the outputs of the command node, causing 
    //      pendingStartSelf() to return true.
    // 
    // CommandNode ignores input files that are not contained in one of the
    // file repositories registered in the execution context.
    // Otherwise the CommandNode registers a file node associated with the 
    // input file in the command node's input set. It will create such a 
    // file node and add it to the execution context if the node did not yet
    // exist.
    //      
    class __declspec(dllexport) CommandNode : public Node
    {
    public:
        typedef std::map<std::filesystem::path, std::shared_ptr<FileNode>> InputNodes;

        CommandNode(); // needed for deserialization
        CommandNode(ExecutionContext* context, std::filesystem::path const& name);
        ~CommandNode();

        // Set the name of input file aspect set. The set is accessed via
        // context()->findFileAspectSet(newName).
        // The command node will only re-execute when input file aspect hash 
        // values have changed since previous command node execution.
        // 
        void inputAspectsName(std::string const& newName);
        std::string const& inputAspectsName(std::string const& newName) const {
            return _inputAspectsName;
        }

        // Pre: newInputs contains SourceFileNode and/or GeneratedFileNode
        // and/or GroupNode instances.
        void cmdInputs(std::vector<std::shared_ptr<Node>> const& newInputs);
        std::vector<std::shared_ptr<Node>> const& cmdInputs() const { return _cmdInputs; }

        // Pre: newInputs contains GeneratedFileNode and/or GroupNode instances.
        void orderOnlyInputs(std::vector<std::shared_ptr<Node>> const& newInputs);
        std::vector<std::shared_ptr<Node>> const& orderOnlyInputs() const { return _orderOnlyInputs; }

        // Set/get the shell script to be executed when this node executes.
        void script(std::string const& newScript);
        std::string const& script() const { return _script; }

        // The directory in which the script will be executed.
        // The repository root directory when nullptr.
        void workingDirectory(std::shared_ptr<DirectoryNode> const& dir);
        std::shared_ptr<DirectoryNode> workingDirectory() const { return _workingDir.lock(); }

        // Set/get the output files generated by this node's script.
        void outputs(std::vector<std::shared_ptr<GeneratedFileNode>> const& newOutputs);
        std::vector<std::shared_ptr<GeneratedFileNode>> const& outputs() const { return _outputs; }

        // newOutputs contains regular expression patterns. Output files that
        // match these patterns are ignored.
        void ignoreOutputs(std::vector<std::filesystem::path> const& newOutputs);
        std::vector<std::filesystem::path> const& ignoredOutputs() const { return _ignoredOutputs; }

        InputNodes const& detectedInputs() const { return _detectedInputs; }

        // Override Node
        void getOutputs(std::vector<std::shared_ptr<Node>>& outputs) const override;
        void getInputs(std::vector<std::shared_ptr<Node>>& inputs) const override;

        void start() override;
        void cancel() override;

        void buildFile(SourceFileNode* buildFile);
        void ruleLineNr(std::size_t ruleLineNr);
        SourceFileNode const* buildFile() const;
        std::size_t ruleLineNr() const;

        static void setStreamableType(uint32_t type);
        // Inherited from IStreamable
        uint32_t typeId() const override;
        void stream(IStreamer* streamer) override;
        // Inherited from IPersistable
        void prepareDeserialize() override;
        bool restore(void* context, std::unordered_set<IPersistable const*>& restored) override;

    protected:
        struct PostProcessResult {
            virtual ~PostProcessResult() {}

            Node::State newState;
            std::set<std::filesystem::path> readFiles;     // read-accessed files
            std::set<std::filesystem::path> writtenFiles;  // write-accessed files
            std::set<std::filesystem::path> readOnlyFiles; // readFiles except writtenFiles 
        };

        // Called, in threadpool context, only after successfull completion of 
        // script execution.
        // Todo: pass stdout of the script.
        // Returned result->newState will be used as result state of script
        // execution.
        virtual std::shared_ptr<PostProcessResult> postProcess(std::string const& stdOut) { return nullptr; }

        // Called, in mainthread context. 
        // Called just before Node::notifyCompletion is called.
        virtual void commitPostProcessResult(std::shared_ptr<PostProcessResult>& result) {}

    private:
        struct ExecutionResult {
            MemoryLogBook _log;
            Node::State _newState;
            std::set<std::filesystem::path> _outputPaths;
            std::set<std::filesystem::path> _keptInputPaths;
            std::set<std::filesystem::path> _removedInputPaths;
            std::set<std::filesystem::path> _addedInputPaths;
            std::vector<std::shared_ptr<FileNode>> _addedInputNodes;
            std::shared_ptr<PostProcessResult> _postResult;

            void newState(Node::State newState) {
                _newState = newState;
                if (_postResult != nullptr) _postResult->newState = newState;
            }

            Node::State newState() const {
                Node::State newPRState = 
                    _postResult != nullptr ? _postResult->newState : Node::State::Ok;
                Node::State newState = Node::State::Ok;
                if (_newState != Node::State::Ok) {
                    newState = _newState;
                } else if (newPRState != Node::State::Ok) {
                    newState = newPRState;
                }
                return newState;
            }
        };

        std::filesystem::path convertToSymbolicPath(std::filesystem::path const& absPath, MemoryLogBook& logBook);
        std::set<std::filesystem::path> convertToSymbolicPaths(std::set<std::filesystem::path> const& absPaths, MemoryLogBook& logBook);
        void handleRequisitesCompletion(Node::State state);
        void executeScript();
        void handleExecuteScriptCompletion(std::shared_ptr<ExecutionResult> result);
        void handleOutputAndNewInputFilesCompletion(Node::State newState, std::shared_ptr<ExecutionResult> result);
        void updateInputProducers();
        void notifyCommandCompletion(std::shared_ptr<ExecutionResult> result);

        bool verifyCmdFlag(
            std::string const& script, 
            std::vector<std::shared_ptr<Node>> const& cmdInputs,
            ILogBook& logBook);
        bool verifyOrderOnlyFlag(
            std::string const& script, 
            std::vector<std::shared_ptr<Node>> const& orderOnlyInputs,
            ILogBook& logBook);
        bool verifyOutputFlag(
            std::string const& script, 
            std::vector<std::shared_ptr<GeneratedFileNode>> const& outputs,
            ILogBook& logBook);
        std::string compileScript(ILogBook& logBook);
        MonitoredProcessResult executeMonitoredScript(ILogBook& logBook);
        void getSourceInputs(std::vector<Node*>& sourceInputs) const;
        void clearDetectedInputs();
        void setDetectedInputs(ExecutionResult const& result);
        XXH64_hash_t computeExecutionHash() const;

        std::shared_ptr<GeneratedFileNode> findOutputNode(
            std::filesystem::path const& outputSymPath,
            MemoryLogBook& logBook);
        bool findOutputNodes(
            std::set<std::filesystem::path> const& outputSymPaths,
            std::vector<std::shared_ptr<GeneratedFileNode>>& outputNodes,
            MemoryLogBook& logBook);
        bool verifyOutputNodes(
            std::vector<std::shared_ptr<GeneratedFileNode>> const& newOutputs,
            MemoryLogBook& logBook);
        bool findInputNodes(
            std::map<std::filesystem::path, std::shared_ptr<GeneratedFileNode>> const& allowedGenInputFiles,
            std::set<std::filesystem::path>const& inputSymPaths,
            std::vector<std::shared_ptr<FileNode>>& inputNodes,
            std::vector<std::shared_ptr<Node>>& srcInputNodes,
            ILogBook& logBook
        );

        // buildFile that contains the rule from which this node is created
        SourceFileNode* _buildFile;
        std::size_t _ruleLineNr;

        std::string _inputAspectsName;
        std::vector<std::shared_ptr<Node>> _cmdInputs;
        std::vector<std::shared_ptr<Node>> _orderOnlyInputs;
        // _inputProducers contains pointers to CommandNode and/or GroupNode
        std::unordered_set<Node*> _inputProducers;
        std::string _script;
        std::weak_ptr<DirectoryNode> _workingDir;
        std::vector<std::shared_ptr<GeneratedFileNode>> _outputs;
        std::vector<std::filesystem::path> _ignoredOutputs;

        std::atomic<std::shared_ptr<IMonitoredProcess>> _scriptExecutor;
        
        // Inputs detected during last script execution
        InputNodes _detectedInputs;

        // The hash of the hashes of all items that, when changed, invalidate
        // the output files. Items include the script, the output files and 
        // the relevant aspects of the input files.
        XXH64_hash_t _executionHash;
    };
}
