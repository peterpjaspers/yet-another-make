#pragma once

#include "Node.h"
#include "FileNode.h"
#include "IMonitoredProcess.h"
#include "MemoryLogBook.h"
#include "../xxHash/xxhash.h"

#include <atomic>

namespace YAM
{
    class GeneratedFileNode;

    // CommandNode is capable of:
    //      - executing a shell script with a given set of output files.
    //    - detecting which files are accessed during the execution of the script.
    //    - checking that the script write-accessed the given set of output files.
    //    - registering the detected read-accessed files as input files.
    //    - detecting changes in script, input and/or output files.
    //      Such changes will out-date the outputs of the command node, causing 
    //      pendingStartSelf() to return true.
    // 
    // CommandNode will lookup the file node associated with a detected input
    // file in the execution context. If found the node will be registered in
    // the command node's input set. If not found CommandNode will check
    // whether the input file is contained in one of the FileRepositories 
    // registered in the execution context. CommandNode execution will fail when
    // this is not the case.
    //      
    class __declspec(dllexport) CommandNode : public Node
    {
    public:
        typedef std::map<std::filesystem::path, std::shared_ptr<FileNode>> InputNodes;

        CommandNode(); // needed for deserialization
        CommandNode(ExecutionContext* context, std::filesystem::path const& name);
        ~CommandNode();
        
        void setState(State newState) override;
        bool supportsPrerequisites() const override;

        // getPrerequisites appends the input producers (command nodes), the source 
        // files (SourceFileNode) that were read during the last execution of this 
        // node and the output files (GeneratedFileNode) to given 'prerequisites'.
        // Source and output files are prerequisites because their executions 
        // compute file hashes that are used by pendingStartSelf to check whether 
        // the outputs of this node are out-dated or have been tampered with.
        // pendingStartSelf also uses the hashes of input files that were generated
        // by the input producers. The input producers must therefore be included in
        // 'prerequisites'to make sure that these generated input files are up-to-date.
        void getPrerequisites(std::vector<std::shared_ptr<Node>>& prerequisites) const override;

        bool supportsOutputs() const override;
        void getOutputs(std::vector<std::shared_ptr<Node>>& outputs) const override;

        bool supportsInputs() const override;
        void getInputs(std::vector<std::shared_ptr<Node>>& inputs) const override;

        bool pendingStartSelf() const override;

        void cancelSelf() override;

        // Set the input file aspects that contribute to the output file(s)
        // of the command node.
        void setInputAspectsName(std::string const& newName);

        // Set the output files generated by this node's execution.
        void setOutputs(std::vector<std::shared_ptr<GeneratedFileNode>> const & newOutputs);

        // Set the shell script to be executed when this node executes.
        // The script must generate all the files specified by setOutputs.
        // Node execution will fail otherwise.
        void setScript(std::string const & newScript);

        // Set nodes that produce outputs that are (allowed to be) used as
        // inputs by this node. The producer nodes must be executed before this 
        // node to make sure that their outputs exist and are up-to-date.
        // Besides these generated inputs this node is also allowed to use 
        // source files as inputs. Source files need not be in newInputProducers.
        // Do not confuse source files with 'source files' generated from e.g.
        // IDL files, yacc and lex files. The nodes that generate such files must
        // be in newIputProducers.
        // This node does not take ownership of the producer nodes.
        void setInputProducers(std::vector<std::shared_ptr<Node>> const & newInputProducers);

        void getInputProducers(std::vector<std::shared_ptr<Node>>& producers) const;

        static void setStreamableType(uint32_t type);
        // Inherited from IStreamable
        uint32_t typeId() const override;
        void stream(IStreamer* streamer) override;
        // Inherited from IPersistable
        void prepareDeserialize() override;
        void restore(void* context) override;

    protected:
        void selfExecute() override;

    private:
        struct ExecutionResult : public Node::SelfExecutionResult {
            // inputs detected during last script execution
            InputNodes _inputs;
            // Difference with previously detected input nodes
            InputNodes _removedInputs;
            InputNodes _addedInputs;
            InputNodes _keptInputs;
            // results of the re-executed (i.e. re-hashed) output nodes
            std::vector<std::shared_ptr<FileNode::ExecutionResult>> _outputNodeResults;
            XXH64_hash_t _executionHash;
        };

        void getSourceInputs(std::vector<std::shared_ptr<Node>> & sourceInputs) const;
        void setInputs(ExecutionResult const* result);
        bool executeOutputFiles(std::vector<std::shared_ptr<FileNode::ExecutionResult>>& outputHashes);
        XXH64_hash_t computeExecutionHash() const;
        XXH64_hash_t computeExecutionHash(ExecutionResult const* result) const;

        std::shared_ptr<FileNode> findInputNode(
            std::filesystem::path const& input,
            MemoryLogBook& logBook);
        bool findInputNodes(
            std::set<std::filesystem::path> const& inputFilePaths,
            std::filesystem::path const& exclude,
            ExecutionResult* result);

        std::shared_ptr<GeneratedFileNode> findOutputNode(
            std::filesystem::path const& output,
            MemoryLogBook& logBook);
        bool findOutputNodes(
            MonitoredProcessResult const& result,
            std::vector<std::shared_ptr<GeneratedFileNode>>& outputNodes,
            MemoryLogBook& logBook);
        bool verifyOutputNodes(
            std::vector<std::shared_ptr<GeneratedFileNode>> const& newOutputNodes,
            MemoryLogBook& logBook);

        MonitoredProcessResult executeScript(
            std::filesystem::path& scriptFile,
        MemoryLogBook& logBook);
        void commitSelfCompletion(SelfExecutionResult const* result) override;

        // The name of the FileAspectSet that contains the aspects relevant for this
        // command, i.e. the aspects of input files that contribute to output file content.
        std::string _inputAspectsName;

        std::vector<std::shared_ptr<Node>> _inputProducers;
        std::vector<std::shared_ptr<GeneratedFileNode>> _outputs;

        // TODO: decide whether script will be streamed to build state.
        // Script can be large, e.g. a link script that links many object
        // files. Not streaming the script implies that all build files need 
        // to be reparsed to re-initialize command scripts. A change in 
        // script can then be detected by comparing its hash with hash 
        // of previous script (that was streamed to build state).
        std::string _script; 

        std::atomic<std::shared_ptr<IMonitoredProcess>> _scriptExecutor;
        
        // inputs detected during last script execution
        InputNodes _inputs;

        // The hash of the hashes of all items that, when changed, invalidate
        // the output files. Items include the script, the output files and 
        // the relevant aspects of the input files.
        XXH64_hash_t _executionHash;
    };
}
