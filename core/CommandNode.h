#pragma once
#include "Node.h"

namespace YAM
{
	class OutputFileNode;

    class __declspec(dllexport) CommandNode : public Node
    {
	public:
		CommandNode(ExecutionContext* context, std::filesystem::path const& name);

		virtual bool supportsPrerequisites() const override;
		virtual void appendPrerequisites(std::vector<Node*>& prerequisites) const override;

		virtual bool supportsOutputs() const override;
		virtual void appendOutputs(std::vector<Node*>& outputs) const override;

		virtual bool supportsInputs() const override;
		virtual void appendInputs(std::vector<Node*>& inputs) const override;

		virtual bool pendingStartSelf() const override;

		virtual void startSelf() override;

		virtual XXH64_hash_t computeExecutionHash() const override;

		// Set the output files generated by this node's execution.
		void setOutputs(std::vector<OutputFileNode*> const & newOutputs);

		// Set the shell script to be executed when this node executes.
		// The script must generate all the files specified by setOutputs.
		// Node execution will fail otherwise.
		void setScript(std::string const & newScript);

		// Set nodes that produce outputs that are (allowed to be) used as
		// inputs by this node. The producer nodes must be executed before this 
		// node to make sure that their outputs exist and are up-to-date.
		// Besides these generated inputs this node is also allowed to use 
		// source files as inputs. Source files need not be in newIputProducers.
		// Do not confuse source files with 'source files' generated from e.g.
		// IDL files, yacc and lex files. The nodes that generate such files must
		// be in newIputProducers.
		// Note: appendPrerequisites appends the newIputProducers, the source files
		// that were read during the last execution of this node and the output
		// files. Source and output files are prerequisites because their execution 
		// computes file hashes that are used by pendingStartSelf to check whether 
		// the outputs of this node are out-dated or have been tampered with.
		// This node does not take ownership of the producer nodes.
		void setInputProducers(std::vector<Node*> const & newIputProducers);

	    void appendInputProducers(std::vector<Node*>& producers) const;


	private:
		void appendSourceInputs(std::vector<Node*> & sourceInputs) const;
		void rehashOutputs();
		Node::State executeScript();
		void execute();

		std::vector<Node*> _inputProducers;
		std::vector<OutputFileNode*> _outputs;

		// TODO: decide whether script will be streamed to build state.
		// Script can be large, e.g. a link script that links many object
		// files. Not streaming the script implies that all build files need 
		// to be reparsed  to re-initialize command scripts. A change in 
		// script can then be detected by comparing its hash with hash 
		// of previous script (that was streamed to build state).
		std::string _script;
		XXH64_hash_t _scriptHash; 

		std::vector<Node*> _inputs; // inputs detected during last script execution
    };
}
