#pragma once

#include "Node.h"
#include "FileNode.h"
#include "FileAspectSet.h"
#include "../xxHash/xxhash.h"

namespace YAM
{
	class OutputFileNode;

    class __declspec(dllexport) CommandNode : public Node
    {
	public:
		CommandNode(ExecutionContext* context, std::filesystem::path const& name);

		virtual bool supportsPrerequisites() const override;

		// appendPrerequisites appends the input producers, the source files
		// that were read during the last execution of this node and the output
		// files. Source and output files are prerequisites because their executions 
		// compute file hashes that are used by pendingStartSelf to check whether 
		// the outputs of this node are out-dated or have been tampered with.
		virtual void appendPrerequisites(std::vector<Node*>& prerequisites) const override;

		virtual bool supportsOutputs() const override;
		virtual void appendOutputs(std::vector<Node*>& outputs) const override;

		virtual bool supportsInputs() const override;
		virtual void appendInputs(std::vector<Node*>& inputs) const override;

		virtual bool pendingStartSelf() const override;

		virtual void startSelf() override;

		XXH64_hash_t computeExecutionHash() const;

		// Set the input file aspects that contribute to the output file(s)
		// of the command node.
		void setInputAspects(FileAspectSet const& newInputAspects);

		// Set the output files generated by this node's execution.
		void setOutputs(std::vector<OutputFileNode*> const & newOutputs);

		// Set the shell script to be executed when this node executes.
		// The script must generate all the files specified by setOutputs.
		// Node execution will fail otherwise.
		void setScript(std::string const & newScript);

		// Set nodes that produce outputs that are (allowed to be) used as
		// inputs by this node. The producer nodes must be executed before this 
		// node to make sure that their outputs exist and are up-to-date.
		// Besides these generated inputs this node is also allowed to use 
		// source files as inputs. Source files need not be in newInputProducers.
		// Do not confuse source files with 'source files' generated from e.g.
		// IDL files, yacc and lex files. The nodes that generate such files must
		// be in newIputProducers.
		// This node does not take ownership of the producer nodes.
		void setInputProducers(std::vector<Node*> const & newInputProducers);

	    void appendInputProducers(std::vector<Node*>& producers) const;

	private:
		void appendSourceInputs(std::vector<Node*> & sourceInputs) const;
		void rehashOutputs();
		Node::State executeScript();
		void execute();

		// The aspects relevant for this comment, i.e. the aspects of input files
		// that contribute to output file content.
		FileAspectSet _inputAspects;

		std::vector<Node*> _inputProducers;
		std::vector<OutputFileNode*> _outputs;

		// TODO: decide whether script will be streamed to build state.
		// Script can be large, e.g. a link script that links many object
		// files. Not streaming the script implies that all build files need 
		// to be reparsed  to re-initialize command scripts. A change in 
		// script can then be detected by comparing its hash with hash 
		// of previous script (that was streamed to build state).
		std::string _script;
		XXH64_hash_t _scriptHash; 

		std::vector<FileNode*> _inputs; // inputs detected during last script execution

		// The hash of the hashes of the script, of the output files and of the
		// the relevant aspects of the input files.
		XXH64_hash_t _executionHash;

    };
}
