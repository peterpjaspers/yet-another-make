#pragma once

#include "DirectoryWatcher.h"
#include "RegexSet.h"

#include <memory>
#include <filesystem>
#include <queue>

namespace YAM
{
	class DirectoryNode;
	class Node;
	class ExecutionContext;

	// A file repository is a directory tree in the file system that contains 
	// yam build files and/or other source files (e.g. C++ source files) and/or
	// files generated by YAM command nodes (e.g. object, library, executable).
	// 
	// A SourceFileRepository mirrors a file repository in memory as a
	// DirectoryNode that contains (sub-)DirectoryNodes and SourceFileNodes.
	// It stores these nodes in an ExecutionContext. YAM will fail a build
	// when it detects an input dependency on a source file that is not in
	// one of YAM's SourceFileRepositories, i.e. when the SourceFileNode
	// associated with the input file is not in the ExecutionContext. 
	// 
	// The user can specify a subset of the directories and files in the 
	// repository to be excluded from the SourceFileRepository. The user 
	// can do so by specifying a set of exclude patterns. File/directory
	// names that match one of these  patterns will be excluded from the 
	// SourceFileRepository and hence will not be present in ExecutionContext.
	// 
	// A SourceFileRepository must not mirror generated files. It is not
	// possible however to distinguish between source and generated files
	// just be looking at file name or extension. SourceFileRepository
	// therefore relies entirely on the exclude patterns to exclude all
	// generated files. If this is not done properly, then havoc will occur 
	// when that file is declared as an output file in a build file. In that
	// case the build file parser will fail to create a GeneratedFileNode for
	// that file because there is already a SourceFileNode with that name.
	// 
	// SourceFileRepository monitors the tree for sub-directory and file 
	// changes and marks changed directory and file nodes as Dirty. Dirty 
	// nodes can be synced with the fileystem state by executing them. 
	// Syncing is not performed by SourceFileRepository.
	// 
	// Comparing build states
	// Node names are absolute path names. This complicates comparing two
	// build states because (clones of) repositories can be stored on 
	// different paths in different builds. The repository name facilitates 
	// comparison because it allows absolute paths to be converted to a 
	// 'symbolic' path of form <repoName>/<path relative to repo directory>
	// 
	class __declspec(dllexport) SourceFileRepository
	{
	public:
		// Mirror given 'directory' recursively in a DirectoryNode.
		// Exclude dirs and files whose paths match given '_excludePatterns'.
		// Register non-excluded directory and source file nodes in given
		// 'context->nodes()'. Make sure that the exclude patterns exclude
		// all generated files in the directory tree.
		//
		SourceFileRepository(
			std::string const& repoName,
			std::filesystem::path const& directory,
			RegexSet const& _excludePatterns,
			ExecutionContext* context);

		std::string const& name() const;
		std::filesystem::path const& directoryName() const;
		std::shared_ptr<DirectoryNode> directory() const;
		RegexSet const& excludes() const;
		void excludes(RegexSet const& newExcludes); 

		// Return whether path is a path in the repo directory tree, 
		// E.g. if directoryName() = /a/b/, then path = /a/b/c/e
		// is a sub path. This is also true when /a/b/c/e does not
		// exist in the file system or when it was excluded by the
		// exclude patterns. 
		bool contains(std::filesystem::path const& path) const;
		
		// Suspend/resume repository change monitoring.
		// While suspended: queue dir and file changes.
		// When resumed: dequeue the changes and mark associated file
		// and dir nodes Dirty.
		// Rationale: change monitoring will result in nodes to become
		// Dirty. Doing so during an on-going build will confuse node
		// execution. Therefore suspend monitoring during a build.
		void suspend();
		void resume();

		// Recursively remove the directory node from context->nodes().
		// Intended to be used when the repo is no longer to be mirrored
		// by YAM.
		void clear();

	private: 
		void _enqueueChange(FileChange change);
		void _processChangeQueue();
		void _handleChange(FileChange const& change);
		void _handleAdd(FileChange const& change);
		void _handleRemove(FileChange const& change);
		void _handleModification(FileChange const& change);
		void _handleRename(FileChange const& change);
		void _handleOverflow();
		std::shared_ptr<Node> _invalidateNode(std::filesystem::path const& path);
		void _invalidateNodeRecursively(std::filesystem::path const& path);
		void _invalidateNodeRecursively(std::shared_ptr<Node> node);

		std::string _name;
		std::shared_ptr<DirectoryNode> _directory;
		ExecutionContext* _context;
		RegexSet _excludes;
		bool _suspended;
		std::queue<FileChange> _changeQueue;
		DirectoryWatcher _watcher;
	};
}
