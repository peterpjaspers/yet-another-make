#pragma once

#include "FileWatcher.h"
#include "RegexSet.h"

#include <memory>
#include <filesystem>
#include <queue>

namespace YAM
{
	class DirectoryNode;
	class Node;
	class ExecutionContext;

	// A file repository is a directory tree that contains build files 
	// and/or other source files (e.g. C++ source files) and/or files
	// generated by YAM command nodes (e.g. object and library files).
	// 
	// A SourceFileRepository mirrors a repository in memory as a
	// DirectoryNode that contains (sub-)DirectoryNodes and SourceFileNodes.
	// It stores these nodes in an ExecutionContext. YAM will fail a build
	// when it detects input dependencies on source files that are not in
	// one of YAM's SourceFileRepositories.
	// 
	// The user can specify a subset of the files in the repository to be
	// included in the SourceFileRepository. The user can do so by specifying
	// a set of exclude patterns. File/directory names that match one of these 
	// patterns will not be included in the SourceFileRepository
	// 
	// A SourceFileRepository will create a SourceFileNode for each file in
	// the repository that is not excluded by the exclude patterns. The exclude
	// patterns must therefore ensure that all generated files are excluded.
	// If this is not done properly, then havoc will occur when that file is
	// declared as an output file in a build file. In that case the build file 
	// parser will fail to create a GeneratedFileNode for that file because 
	// there is already an existing SourceFileNode with that name.
	// 
	// SourceFileRepository monitors the tree for sub-directory and file 
	// changes and marks changed directory and file nodes as Dirty. Dirty 
	// nodes can be synced with the fileystem state by executing them. 
	// Syncing is not performed by SourceFileRepository.
	// 
	class __declspec(dllexport) SourceFileRepository
	{
	public:
		// Mirror given 'directory' recursively in a DirectoryNode.
		// Exclude dirs and files whose paths match given '_excludePatterns'.
		// Register non-excluded directory and source file nodes in given
		// 'context->nodes()'.
		//
		SourceFileRepository(
			std::string const& repoName,
			std::filesystem::path const& directory,
			RegexSet const& _excludePatterns,
			ExecutionContext* context);

		std::string const& name() const;
		std::filesystem::path const& directoryName() const;
		std::shared_ptr<DirectoryNode> directory() const;
		RegexSet const& excludes() const;
		void excludes(RegexSet const& newExcludes); 
		// Return whether path is a path in the repo directory tree, 
		// Ignore existence of path, ignore excludes.
		// E.g. if directoryName() = /a/b/, then path = /a/b/c/e
		// is a sub path.
		bool isSubpath(std::filesystem::path const& path) const;
		
		// Suspend/resume repository change monitoring.
		// While suspended: queue dir/file changes.
		// When resumed: dequeue dir/file changes and mark associated
		// file/dir nodes Dirty.
		void suspend();
		void resume();

		// Recursively remove the directory node from context->nodes().
		// Intended to be used when the repo is no longer to be mirrored
		// by YAM.
		void clear();

	private: 
		void _enqueueChange(FileChange change);
		void _processChangeQueue();
		void _handleChange(FileChange const& change);
		void _handleAdd(FileChange const& change);
		void _handleRemove(FileChange const& change);
		void _handleModification(FileChange const& change);
		void _handleRename(FileChange const& change);
		void _handleOverflow();
		std::shared_ptr<Node> _invalidateNode(std::filesystem::path const& path);
		void _removeNodeRecursively(std::shared_ptr<Node> node); 
		void _invalidateNodeRecursively(std::filesystem::path const& path);
		void _invalidateNodeRecursively(std::shared_ptr<Node> node);

		std::string _name;
		std::shared_ptr<DirectoryNode> _directory;
		ExecutionContext* _context;
		RegexSet _excludes;
		bool _suspended;
		bool _changeOverflow;
		std::queue<FileChange> _changeQueue;
		FileWatcher _watcher;
	};
}
