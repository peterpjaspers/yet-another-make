#pragma once

#include "RegexSet.h"
#include "IDirectoryWatcher.h"

#include <memory>
#include <filesystem>
#include <queue>

namespace YAM
{
	class DirectoryNode;
	class Node;
	class ExecutionContext;

	// A file repository is a directory tree in the file system that contains 
	// yam build files and/or other source files (e.g. C++ source files) and/or
	// files generated by YAM command nodes (e.g. object, library, executable).
	// 
	// A SourceFileRepository mirrors a file repository in memory as a
	// DirectoryNode that contains (sub-)DirectoryNodes and SourceFileNodes.
	// It stores these nodes in an ExecutionContext. YAM will fail a build
	// when it detects an input dependency on a source file that is not in
	// one of YAM's SourceFileRepositories. 
	// 
	// The user can specify a subset of the directories and files in the 
	// repository to be excluded from the SourceFileRepository. The user 
	// can do so by specifying a set of exclude patterns. File/directory
	// names that match one of these  patterns will be excluded from the 
	// SourceFileRepository and hence will not be present in ExecutionContext.
	// 
	// A SourceFileRepository must not mirror generated files. It is not
	// possible however to distinguish between source and generated files
	// just be looking at file name or extension. SourceFileRepository
	// therefore relies entirely on the exclude patterns to exclude all
	// generated files. If this is not done properly, then havoc will occur 
	// when that file is declared as an output file in a build file. In that
	// case the build file parser will fail to create a GeneratedFileNode for
	// that file because there is already a SourceFileNode with that name.
	// 
	// SourceFileRepository monitors the tree for sub-directory and file 
	// changes and marks changed directory and file nodes as Dirty. Dirty 
	// nodes can be synced with the fileystem state by executing them. 
	// Syncing is not performed by SourceFileRepository.
	// 
	// Comparing build states
	// Node names are absolute path names. This complicates comparing two
	// build states because (clones of) repositories can be stored on 
	// different paths in different builds. The repository name facilitates 
	// comparison because it allows absolute paths to be converted to a 
	// 'symbolic' path of form <repoName>/<path relative to repo directory>
	// 
	// The intended use of SourceFileRepository is to create source file
	// nodes before executing command nodes.
	// Rationale: assume that the source file node for file F would be created 
	// (and its hashes computed) when it is detected as input of command node C.
	// In this scenario the following race condition may occur: the user edits F
	// in the time interval between completion of the command script of C and 
	// the subsequent retrieval of F's last-write-time and computation of F's 
	// aspect hashes. In this case the next build will not detect that F has 
	// changed (because F's last-write-time has not changed). As a result C will 
	// not re-execute, resulting in wrong content of C's output files.
	// 
	// This problem can be fixed in several ways:
	//    1- Do not allow modification of source files during the build.
	//    2- Capture last-write-time and hash code of F before using it.
	//       Because input files are detected during command node execution
	//       this can can only be implemented by creating file nodes for all 
	//       files in the worktree before starting command node execution (as
	//       intended by SourceFileRepository).
	//    3- Detect which source files are modified during the build.
	//       At next build force the commands that used these files as input
	//       to re-execute.      
	// Option 1 is not user-friendly and not easy to implement.
	// Option 2 is easy to implement and simplifies handling input file
	// detection during command node execution because the file node and its 
	// hashes already exist at that time. Disadvantage is that it may result in
	// more file nodes than actually used as inputs.
	// Option 3 may cause unnecessary re-builds in case the file was modified 
	// before it was used as input. Also different commands may use the same 
	// input at different times. This complicates the implementation.
	//
	// Option 2 does not apply to generated files. Generated files are, like
	// source files, created and hashed before command execution. But after 
	// command execution their hashes have to be re-computed because the 
	// execution changes their content. This creates the possibility for the
	// earlier described race condition. Option 3 is hard to implement because
	// it is hard to distinguish between modifications resulting from command
	// execution and from the user tampering with the output files.
	//
	class __declspec(dllexport) SourceFileRepository
	{
	public:
		// Mirror given 'directory' recursively in a DirectoryNode.
		// Exclude dirs and files whose paths match given '_excludePatterns'.
		// Register non-excluded directory and source file nodes in given
		// 'context->nodes()'. Make sure that the exclude patterns exclude
		// all generated files in the directory tree.
		//
		SourceFileRepository(
			std::string const& repoName,
			std::filesystem::path const& directory,
			// TODO: do not pass exclude patterns here.
			// Instead let each DirectoryNode retrieve exclude patterns from 
			// .yamignore, or if absent, from .gitignore.
			RegexSet const& _excludePatterns,
			ExecutionContext* context);

		// Construct a read-only repository. A read-only repository is not
		// mirrored in memory and directory() is a nullptr. Command nodes
		// are allowed to depend on files in a read-only repository but 
		// do not (and cannot because file nodes are not created) register 
		// dependencies on these files.
		//
		SourceFileRepository(
			std::string const& repoName,
			std::filesystem::path const& directory);

		bool readOnly() const;
		std::string const& name() const;
		std::filesystem::path const& directoryName() const;
		std::shared_ptr<DirectoryNode> directory() const;
		RegexSet const& excludes() const;
		void excludes(RegexSet const& newExcludes); 

		// Return whether path is a path in the repo directory tree, 
		// E.g. if repo directoryName() = /a/b/ and path = /a/b/c/e then
		// repo contains path. This is also true when /a/b/c/e does not
		// exist in the file system or when it was excluded by the
		// exclude patterns. 
		bool contains(std::filesystem::path const& path) const;
		
		// Suspend/resume repository change monitoring.
		// While suspended: queue dir and file changes.
		// When resumed: dequeue the changes and mark associated file
		// and dir nodes Dirty.
		// Rationale: change monitoring will result in nodes to become
		// Dirty. Doing so during an on-going build will confuse node
		// execution. Therefore suspend monitoring during a build.
		void suspend();
		void resume();

		// Recursively remove the directory node from context->nodes().
		// Intended to be used when the repo is no longer to be mirrored
		// by YAM.
		void clear();

	private: 
		void _enqueueChange(FileChange change);
		void _processChangeQueue();
		void _handleChange(FileChange const& change);
		void _handleAdd(FileChange const& change);
		void _handleRemove(FileChange const& change);
		void _handleModification(FileChange const& change);
		void _handleRename(FileChange const& change);
		void _handleOverflow();
		std::shared_ptr<Node> _invalidateNode(
			std::filesystem::path const& path,
			std::chrono::time_point<std::chrono::utc_clock> const& lastWriteTime);
		void _invalidateNodeRecursively(std::filesystem::path const& path);
		void _invalidateNodeRecursively(std::shared_ptr<Node> const& node);

		bool _readOnly;
		std::string _name;
		std::shared_ptr<DirectoryNode> _directory;
		ExecutionContext* _context;
		RegexSet _excludes;
		bool _suspended;
		std::queue<FileChange> _changeQueue;
		std::shared_ptr<IDirectoryWatcher> _watcher;
	};
}
