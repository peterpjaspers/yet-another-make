#pragma once

#include "BuildFileTokenizer.h"
#include "BuildFile.h"
#include <filesystem>
#include <string>
#include <vector>
#include <memory>

namespace YAM
{
    // Parses a text in buildfile syntax into a BuildFile::File.
    // 
    // Buildfile syntax is inspired by tup buildfile syntax, see 
    // https://gittup.org/tup/manual.html
    // Syntax and semantics however are NOT tup compatible.
    /*
    
    Syntactical symbols:
    {A B}* =>  0, 1 or more times A B
    {A B}+ =>  1 or more times A B
    [A B]  =>  optional A B
    A|B    =>  A or B

    Syntax:

        BuildFile :== {Dependency}* {Rule}*

        Dependency :== DepBuildFile | DepGlob
        BuildFile :== 'buildfile' Path | Glob
        DepGlob :== 'glob' Glob
        DirPath :== Path

        // TODO: add ignored outputs.
        // Move syntax description to documentation.
        //
        Rule :== ':' [foreach] [CmdInputs] [ '|' OrderOnlyInputs ] '|>' Script '|>' [Output] { [Output] | [Group] | [Bin] }*
        CmdInputs :== [Input]*
        Input :== Path | Glob | Exclude | [Group]
        Exclude :== '^'Path | '^'Glob
        Glob :== Path with glob special characters (* ? [])
        OrderOnlyInputs :== { Path | [Group] }*
        Script :== { identifier | InputPathFlag | OutputPathFlag }+
        InputPathFlag :== %[Index] 'f' | '%b' | '%B' | '%e' | '%D' | '%d'
        Index :== integer
        OutputPathFlag :== '%o'
        Output :== OutputPath | '^'Path // ^path excludes tracking of path
        OutputPath :== Path containing InputPathFlag
        Path :== RelPath | RepoPath
        RelPath :== identifier [ { '/'identifier }* ]
        RepoPath :== '<' RepoName '>/' AbsPath
        RepoName :== identifier
        Group :== Path where last path component is between angled brackets.
                  E.g. ..\modules\<someGroupName>
        Bin :== '{' identifier '}'

    Semantics:

    Dependency: a changed dependency triggers re-execution of the buildfile.

    DepBuildFile: buildfile A depends on buildfile B when A uses inputs that are
    outputs of rules in B. The buildfile path is the path of the directory that
    contains the buildfile. This is convenient because the extension of the
    buildfile may vary across directories and over time (because buildfile 
    language can be changed, cause buildfile extension to change. E.g. from
    .bat to .py).

    DepGlob: buildfile A depends on glob G when A produces a set of rules that
    depends on the set of files that match G. E.g. the buildfile produces a 
    rule for each .cpp file in a the src directory. In that case there is a
    dependency on glob src\*.cpp. Note: the buildfile could also have produced
    a single foreach rule with input src\*.cpp. In that case yam evaluates the
    glob and adds the glob as a dependency of the buildfile.

    Group: a set of file paths. The group is identified by a unique path name.
    Outputs Group: yam will add all output paths to the specified group.

    CmdInputs: yam expands this into a list of file paths resulting from 
    evaluating the Globs, Paths and Excludes plus the file paths in the 
    referenced group(s). An Exclude removes all paths previously included that 
    match the Path or Glob specified in the Exclude.
    CmdInputs refer to source files and/or generated files. The generated files
    must have been defined, as outputs of a rule, before they can be used as
    inputs. CmdInputs serve two purposes:
        - the command script can reference input files by means of %-flags
        - build-ordering: yam ensures that input generated files are made
          up-to-date before executing the command script.

    Glob: a path that contains glob patterns, see class Glob. Globs are only
    supported for source files.

    OrderOnlyInputs: a list of generated files. Yam ensures that these files
    are made up-to-date before executing the command script.

    RelPath: a relative path, relative to the directory that contains the
    buildfile.

    Repository: a directory tree that contains buildfiles and/or source files
    and/or files generated by yam.

    AbsPath: a symbolic path in one of the configured repositories. A symbolic
    path represents an absolute path in a repository. In a symbolic path the
    repository root directory is replaced by the repository name. This allows
    repositories to be moved to other directories without having to modify
    build files.

    InputPathFlags:
    The %f, %b, %B, %e, %d and %D flags transform one or more paths in the
    expanded CmdInputs. In a foreach rule they transform the current file path
    in the cmd inputs. In a non-foreach rule they transform all paths in the 
    cmd inputs.

        %f Path, e.g. c/d.e -> c/d.e
        %b File name, e.g. c/d.e -> d.e
        %B File base name, e.g. c/d.e -> d
        %e File extension, e.g. c/d.e -> e
        %d Directory, e.g b/c/d.e -> b/c
        %D Lowest level directory, e.g. b/c/d.e -> c

    The %i flag selects all file paths in the expanded OrderOnlyInputs.
        %i Path, e.g. c/d.e -> c/d.e
    
    Index: in case the %-flag is followed by integer idx then the %-flag
    transforms ExpandedCmdInputs[idx] cq ExpandedOrderOnlyInputs[idx].
    E.g. expanded inputs are (pathA, pathB, pathC), then %2b tranforms pathC
    into file name of pathC.

    Rule: defines a command script that transforms input files to output files.
    Rule order matters: a rule that defines output A must be defined before a
    rule can use A as input.

    OutputPathFlag semantics:
        %o -> path names resulting from Outputs (after processing the %-flags
              in Outputs).

    Exec: an exec path B in buildfile A identifies a buildfile that defines 
    outputs that are used as inputs by buildfile A. Yam will process B before
    it processes the rules generated by A to ensure that all generated inputs
    inputs in A are defined.

    Group: a group collects outputs of one or more rule. The content of a group 
    can be used as inputs in one or more other rules. Groups are referenced by
    their name (a path, see Path).
    Given some group G then only one buildfile, say BFG, is allowed to define G,
    i.e. to add outputs to G. In BFG all rules that add output to G must occur 
    before the first rule that uses G as input. Buildfiles that reference G must
    exec buildfile BFG.
    
    Example rules:

    # Rule to compile main.c and bar.c and link the resulting
    # object files into an executable program
    : |> gcc -c main.c -o main.o |> main.o
    : |> gcc -c bar.c -o bar.o |> bar.o
    : main.obj bar.obj |> gcc main.obj bar.obj -o program |> program.exe

    # Same as above but using foreach and %-flags and collecting all object
    # files into a group
    : foreach main.c bar.c |> gcc -c %f -o %o |> %B.o {objs}
    : {objs} |> gcc main.obj bar.obj -o program |> program.exe

    # Same as above but compiling all cpp files in src directory
    : foreach src/*.c |> gcc -c %f -o %o |> %B.o {objs}
    : {objs} |> gcc %f -o %o |> program.exe

    # Two buildfiles: one that compiles all cpp files and collects the
    # resulting objects files in a group and one that links the (object
    # files in the) group into an executable program.
    #
    # <repoRoot>/p/q/buildfile_yam.py:
    : foreach src/*.c |> gcc -c %f -o %o |> %B.o {objs}

    # <repoRoot>/p/r/buildfile_yam.rb:
    import ../q
    : {../q/objs} |> gcc %f -o %o |> program.exe

    */

    class __declspec(dllexport) BuildFileParser
    {
    public:
        BuildFileParser(std::filesystem::path const& buildFilePath);
        BuildFileParser(std::string const& buildFileContent, std::filesystem::path const& buildFilePath = "test");
        BuildFileParser(std::string && buildFileContent, std::filesystem::path const& buildFilePath = "test");

        std::shared_ptr<BuildFile::File> const& file() { return _file; }

    private:
        void lookAhead(std::vector<ITokenSpec const*> const& specs);
        Token eat(ITokenSpec const* toEat);
        void syntaxError();

        std::shared_ptr<BuildFile::File> parseBuildFile();
        void eatDep(BuildFile::Deps& deps);
        void eatDepBuildFile(BuildFile::Deps& deps);
        void eatDepGlob(BuildFile::Deps& deps);
        std::shared_ptr<BuildFile::Rule> eatRule();
        void parseInputs(BuildFile::Inputs& inputs);
        void eatInput(BuildFile::Input& input);
        void parseOrderOnlyInputs(BuildFile::Inputs& inputs);
        void eatScript(BuildFile::Script& script);
        void parseOutputs(BuildFile::Outputs& outputs);
        void eatOutput(BuildFile::Output& output);
        Token eatGlobToken();
        std::filesystem::path eatGlob();
        std::filesystem::path eatPath();

        std::filesystem::path _buildFilePath;
        BuildFileTokenizer _tokenizer;
        Token _lookAhead;
        std::shared_ptr<BuildFile::File> _file;
    };
}


