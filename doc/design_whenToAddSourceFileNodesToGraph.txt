
- When to add sourcefile nodes to the graph?
	1) when it is detected as input file of a command node
	2) upfront, adding all source files in the repository
  Option 1) has the disadvantage that sourcefile hash is computed after it has been used as input.
  When the user modifies the sourcefile after it was used as input and before its hash is computed (which
  happens after script completion) then this invalidates the output file. This would not be a problem
  if the command node is re-executed at next build. The current implementation however will fail to do so:
      - the lastWriteTime and hash of the modified file are recorded after script completion.
      - the file modification will be detected by the 'file modification detector' and the file will be set 
        Dirty at next build.
      - At next build hash filenode will not recompute hash because lastWriteTime has not changed (unless 
        user made more modifications to file). But even if filenode did recompute the file hash then it would 
        still be the same.
      - Result: command node 'sees' unchanged input file and does not re-execute itself.
  In mrmake this was solved by forcing a re-compute of all parents of the files-modified-during-build
  Note that the same problem (and solution) applies to outputfiles that are tampered with between their time 
  of creation and time of hash computation. The problem however is more complex because outputfiles are (by intent)
  modified during the build by the command script. This requires YAM to distinguish between file modification 
  notifications caused by the command script and caused by other actors. In mrmake that was possible because
  CBFS modification notification is synchronous and provides the process id that caused file modification.
  
  Option 2) does not have the complication of option 1). It will however add file nodes that will never be
  used as inputs of command nodes and thus increase graph size unnecessarily. It is also no solution for modification
  of output files during the build.

  Note that YAM's promise is that, in absence of file modifications since last build, all outputfiles are up-to-date and 
  all obsolete outputfiles have been deleted. Hence ideally tampering with outputfiles would never be needed.
  In practice however, even with a flawless YAM, engineers often force a "clean" build by deleting outputfiles. 
  This is not without rationale: even though YAM may be flawless the build scripts themselves may be not.

  Edits of source files during a build are happen frequently and are part of normal workflow.

  Conclusion: YAM must be robust for both cases.
