A command node computes output files from a set of input files. 
The command stores the versions of the used input files by means of their hashes.
When input files are modified their hashes are recomputed. 
A command node remembers the hashes of the input files by storing its executionHash:
	executationHash = hashOf(hashes of input files, output files, script) 
The command node detects changes in input files by comparing the stored executionHash
with the current executionHash. A changed executationHash results in re-execution of 
the command. 

In some cases only part of the content of an input file is relevant to the computation.
E.g. a compile command has .h and .cpp input files. The comments in these files are irrelevant for
the compilation. The command node can use a hash of the input file only hashes the code
sections and excludes the comment sections. Changing comments in the file will not change that 
hash and hence will not result in recompilation.
E.g. a dll or exe that depends on a dll is linked with the import library .lib files of that dll.
Only the exported symbols (i.e. the interface of the dll) in the .lib file are relevant when
linking the dll/exe with the .lib file. Changing the implementation of the dll will not affect
the exported symbols and hence will not affect the hash of the exported symbols and hence will 
not result in relinking of the dlls/exes that link the .lib file.

The user of YAM can configures a set of FileAspectHashers. A hasher has the following properties:
    - aspectName - the name of the aspect being hashed, e.g. code, dllExports
    - one or more filename patterns (regexes) - the aspect is applicable for files whose name match
      one of the patterns. E.g. C++ input files of a compilation have are .cpp, .h, .hpp
    - hasher function - a function that hashes the relevant aspect of the file

To avoid unnecessary re-execution a CommandNode must use for each input file the aspect hash
relevant for that command.
E.g. a C++ compile command will use the code aspect hasher for .cpp and .h input files
E.g. a packing command will use the entireContent hasher, irrespective of file type.
E.g. a C# assembly creation command will use the dotNetAssemblyInterface for its assembly dependencies. 
E.g. a C++/C link command will use the dllExports hasher for dll import libraries.
     Note: dll import lib has default file extension .lib. Static libs however use the same extension.
     This can be solved by the hasher detecting the actual file type (like done in mrmake) or by using
     file naming conventions that allow one to distinguish between import libs and static libs.

How to define the mapping CommandNode -> input file -> relevant aspect?
Option 1: define the mapping as part of the command rule in the build file
Option 2: define the mapping by means of output file pattern
Command nodes are typically derived from the same rule template and produce output files with the same extension.
E.g. a compile command has .obj output files and .h and .cpp input files.
E.g. a dll link command has .dll output file and .obj and/or .importlib and/or .staticlib input files.
Also command node names are derived from the first output file name. This suggests that option 2 is a convenient
way to define the mapping. 
E.g. the mapping can be defined by a vector of InputFileAspects:
    // class that defines which input file aspects are relevant for the computation of 
    // a specific outputfile type.
    class InputFileAspects {
	private:
		Regex outputfilePattern;
		std::vector<Regex, std::name> _inputFileAspect// input file pattern => aspect name
	public:
        	bool applicableFor(std::filesystem::path outputFile);
        	std::string & const aspectNameFor(std::filesystem::path inputFile);
    }

Note that this may require adoption of file naming conventions to allow for proper differentiation in output file patterns.
A command node with output file X uses the mapping with the output file pattern that matches X.

FileAspectHashers and InputfileAspects definitions are read from a configuration file. Changes in this file do not require 
immediate re-execution of commands. Note that re-execution is likely to occur when file and command nodes gets Dirty because
the executionHash during last build was computed with the old inputfile aspect hashes while the newly computed executionHash 
will be computed with the new inputfile aspect hashes, likely causing the node to be pendingSelfExecution. This will even
happen when the command input files did not actually change
FileAspectHashers and InputFileAspects are best defined in a single configuration file to simplify detection of 
duplicate aspect names, references to non-existing aspects (from InputFileAspects) and duplicate outputfile patterns.

FileAspectHashers and InputFileAspects are stored in the ExecutionContext.
This is used by CommandNode and FileNode as follows:
	- command node executes script:
		- detects input files
		- queries ExecutionContext for its InputFileAspects
		  This query must be MT-safe (even though no updates will take place during build).
		- for each input file { request input file for hash of relevant aspect }
	- input file
		- if hash already computed: return it
		- else
			- query ExecutionContext for FileAspectHasher
		          Query must be MT-safe 
                        - use hasher to compute aspect hash
			- store hash in in member var (std::map<aspectName => hashValue>)
                          This must be MT-safe (even though no updates will take place during build).
	- once a hash for a certain aspect is requested the input file will always compute that hash during
	  its self-execution.
	- the aspect is removed from the input files when the hasher for the aspect is removed from the configuration
          (and consequently the aspect is removed from all InputFileAspects)	

Removing a pattern requires the aspect to be removed from all FileNodes that are no longer applicableFor the modified aspect.
Removing a hasher requires the aspect to be removed from all FileNodes.

When are hashers added/modified/removed?
Hasher definitions are taken from a configuration file. Whenever this file changes all FileNodes need to be inspected.