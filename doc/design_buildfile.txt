---Build systems and their buildfiles
Build systems allow developers to define the command DAG in one or more buildfiles. 
Two types of buildfile syntaxes can be distinguished:
    - declarative Domain Specific Language (DSL)
      Examples: make's makefiles, tup's tupfile, mrmakes rules, tools and dep files.
    - imperative General Purpose Language (GPL)
      The buildsystem provides a library to facilitate command node creation.
      Examples: Bazel's Skylark, tup's Lua

---Yam buildfile
No consensus seems to exist on what approach is best nor on what GPL or DSL is best.
Yam therefore choses, at least for now, to support a hybrid approach inspired by 
tup's rule syntax and by tup's 'run script' feature. In this approach a yam 
buildfile is an executable program with a well-known name, e.g. buildfile.yam.
When executing a buildfile it outputs rules to stdout. Rule syntax is derived from
tup, see section Rule syntax.
Yam interprets the rule output to create command nodes in its DAG.

Yam makes no assumptions about the language used by the buildfile program.
This implies that yam does not provide a GPL support library to facilitate
generating rules. E.g. a function to generate a compile rule, a link rule, etc.
These functions simplify buildfiles to a series of calls to functions that output
the appropriate rules.

Note: Yam has/had the ambition to support a buildfile language that strictly
seperates rule definitions from dependency declarations. This is hard to
implement without a DSL. Yam drops this ambition, at least for now.

---Buildfile dependencies
A buildfile dependency is input used by the buildfile to generate its rule output.
Yam will re-execute a buildfile when one or more of its dependencies change.
Yam will then update the previously generated set of command nodes from the
newly ouputted rules (i.e. keep nodes in the intersection with previous set, 
remove nodes not in new set, add nodes not in previous set). 

Three types of buildfile dependencies exist:
    - buildfile
    - file
    - directory

Buildfile A has a dependency on buildfile B when rules in A use input files that
are generated by rules in B.
When processing buildfile A yam will first process A's buildfile dependencies
(recursively) before processing the rules output of A. The reasons for this is
that yam needs to know whether an input file is a source file or a generated
file (i.e. an output file of another rule/command). It is not possible to 
distinguish a source from a generated file by its name because yam does not enforce
file naming conventions. Therefore first all generated file nodes must be created 
in the graph. Yam can then lookup the file node given the input filename. This 
either results in a nullptr (the file does not exist in the mirrored repo) or a 
SourceFileNode or a GeneratedFileNode.
The buildfile program must inform yam about its buildfile dependencies by outputting 
their names to stdout.
Note: an alternative to buildfile dependencies is a 2-phase processing of buildfiles:
    1- first collect all rules of all buildfiles
    2- then create all command nodes and output files (GeneratedFileNode)
    3- then complete command nodes by defining their input nodes and scripts

Buildfile A has a dependency on file F when A uses the content of F to create
rules. E.g. A reads a file that defines the compilation options used in the
compilation rules created by A.
Yam detects file dependencies automatically by monitoring file access of the
buildfile execution.

BuildFile A has a dependency on directory D when it use D to create rules.
E.g. to create a compilation rule for each source file in directory D.
Yam could detect directory dependencies like it does detect file dependencies.
In mrmake directory dependencies and dependencies on non-existing files were 
ignored because they often cause unnecessary re-execution. E.g. an include file I 
is searched for in directories P, Q and R respectively. Assume I is found in R. 
Now all changes in P, Q and R cause re-exec of the buildfile while only adding or 
moving I to P or Q justifies such re-executions.
On the other hand: if such a move takes place then yam will produce wrong results.
How to deal with this? E.g. what to do with a file_exists(P\Q\R\I) call.
Must yam then register dependencies on P, Q, R or only on P\Q\R\I?

---Rule syntax
Yam rule syntax is simplified tup rule syntax. See file rule_syntax.txt.
Simplifications: no variables, subset of flags. 
Things could be be further simplified by removing foreach support. The foreach is
then implemented in the GPL in the buildfile program. This eliminates substitution 
of %f and other flags. The cmd script can be passed literally to a shell or directly
to the OS. Without foreach a rule defines one command.
For the time being yam will support foreach rules. Rationale: Yam caches directories
and glob results. Such caches cannot be implemented in the buildfile logic. Hence
yam foreach support will result in faster processing of buildfiles.

---Finding buildfiles and detecting changed buildfiles.
Alternatives for finding buildfiles:
    A- recursively search for buildfile.yam files in repo directory tree
    B- declare all buildfiles in a single buildfiles.yam file. This file is 
       stored in the repo root directory.
       Note: in this approach buildfile dependencies can be declared in 
       buildfiles.yam.

---Recursively search for buildfile.yam files in repo directory tree
When searching buildfiles in the repo tree yam must cache directories, i.e.
mirror the repo dir tree, in order to provide beta build behavior on buildfile
changes: when a buildfile is added to some dir D then yam will be notified of
a change in D and yam will mark directory node D dirty. On subsequent build
yam will re-retrieve the content of D and detect the new buildfile.

In design_getRidOfRepoMirroring.txt however we decided to get rid of the repo
mirroring proposed in design_whenToAddSourceFileNodesToGraph.txt.
The main reason to get rid of mirroring was the long time it will take (in the 
first build) to hash all files in the repo. But as explained in
design_getRidOfRepoMirroring.txt, it is no longer necessary to compute the file
hashes during mirroring. Instead hashing a file is only done when it is detected
as a dependency of a command. Hence only, relatively cheap, directory hashes need
to be computed during mirroring.

After the repo mirror has been brought up-to-date yam must find the 
added/changed/removed buildfiles. To avoid O(N) behavior (where N is number of 
nodes in graph) ExecutionContext must keep track of added/changed/removed nodes. 
This optimization is also important in finding the modified command nodes and in
finding the nodes that need to be added/updated/removed in persistent buildstate.

---Declare all buildfiles in a single buildfiles.yam file
Mirroring the repo tree can be avoided by registering all buildfiles in 
buildfiles.yam. Disadvantages: 
    - such a file will be a hotspot (i.e. frequently changed by different
      developers).
    - rules may contains globs, requiring directory content to be retrieved anyway.
    
---Detailed description of 2-phase processing of buildfiles
Phase 1: 
    Foreach outdated buildfile node {
        Parse build file
        For each rule {
            Find/create CommandNode
            For each rule output file {
                Find/create GeneratedFileNode
                Add to command output nodes
            }
    }

Phase 2:
     Foreach outdated buildfile node {
         Foreach command node C created from this build file {
              inputNodes = {}
              For each input file F of C {
                  generatedNode = findGeneratedFileNode(F)
                  If (generatedNode != null) {
                      inputNodes.add(generatedNode);
                  } else {
                      // We will not add src file nodes as inputs as these will
                      // be discovered during script execution.
                  }
               }
               C.setGeneratedInputs(inputNodes)
               C.script = rule.script
        }
    }

Note that this allows (non order-only) input generated files to be selected by globs. 
For example:
: foreach *.c |> gcc -c %f -o %o |> outputDir\%B.o // compile all c-files 
: outputDir\*.o  |> gcc %f -o %o |> program // link the resulting object files
Note that evaluating this glob is O(N) where N is number of nodes in the DAG. N can
be reduced by only applying the glob to generated files nodes that are in scope, i.e.
the nodes defined in this buildfile and its buildfile dependencies.

---Undefined outputs
Some users of tup complain about having to declare all outputs of a rule.
E.g. tup cannot support a cmd script that unzips a zip file. In yam we consider
supporting this scenario, e.g. by : 
     |> unzip archive.zip outputdir |> outputdir\*
yam will detect the output files at command execution time and create for each
detected output file a GeneratedFileNode. Such dynamically detected outputs cannot 
be used in foreach rules. It is possibly though to specify an order-only
input glob. E.g. 
: |> unzip archive.zip outputdir & echo done > outputdir\done.txt |> outputdir\* outputdir\done.txt
: | outputdir\done.txt |> zip outputdir out.zip |> out.zip
or, using tup's group/bin feature:
: |> unzip archive.zip outputdir |> outputdir\* {unzip}
: | unzip |> zip outputdir out.zip |> out.zip