Todo for R 0.1.0
Bugs
- fix (header->free == 1)  throw std::string(signature) + " - Accessing freed page.";
  Reproduce with coreTests EnduranceTest

Features
- support foreach <group>
  Example: 
       raw_images.zip |> unzip %f -out rawImages |> rawImages/*.jpeg <raw_images>
       foreach <raw_images> |> processImage.exe %f -out %o |> processedImages/%b <processed_images>
       <processed_images> |> zip %f -out %o |> processed_images.zip

  Currently 'foreach <raw_images>' translates to 1 CommandNode and %f expands
  to all files in <raw_images>. 
  Intent here however is to create CommandNode for each file in <raw_images>. 
  This is currently not supported by yam because files in group are only known
  after execution of all command nodes that contribute to <group>. So to 
  support this we must transfer compilation of foreach-file-in-group to the 
  1 (ForEach)CommandNode created at buildfile compile-time.
  Also different syntax may be needed to distinguish current foreach from
  foreach-file-in-group. For now we take foreach to mean for each file in
  in input group

  ForEachCommand takes input group(s), command script and outputspecs
  Instantiates CommandNode for each file in input group(s).
  Executes these child CommandNodes.
  Note: At compile-time ForEachCommand is created and added to <processed_images>.
  GroupNode must include for a ForEachCommand all output files of its child 
  CommandNodes.  

- buildscope: current implementation only searches for the producers of dirty 
  generated file nodes. Could also search all dirty nodes to allow for example:
      yam *.cpp // hash file nodes
      yam buildfile_yam.txt // compile buildfile, or execute all commands 
                            // produced by buildfile
      yam submodules/<objects> // execute group

- integrate Phil's file access monitor
    - how to deal with input dependencies on non-existing source files
      Note: these source file nodes are NOT in state Deleted. How to GC these
      nodes when no longer refd => GC sweep over context to remove node with
      use_count 1. delete when not observed
    - directory enumeration
    - After execution (hashing) of detected input and output files: check whether
      last write times match the ones provided by access monitor. If not equal
      then fail the execution and invalidate the execution hash to force command 
      to re-execute at next build. 

- fileaspect configuration
      - hash = last-write-time (e.g. for generated files in cmd executionhash)
      - import lib exports hash (hash i/f of dll)
- response files
- xxhash stream
- build yam with yam
- deal with dependencies on gtest, boost, xxhash
  xxhash requires license to be part of binary redistribution.
- license
- C++20 modules support
  Allow commands to generated buildfiles.
  while (dirty buildfiles found) build();
- end-to-end testing (automated gtest)
- scalability measurements
- documentation
- inform Mike Shal

Out-of-scope:
- distributed build
- build cache (read MS buildXL section on caching!)
- btree/page caching
- tup-compatible syntax
- variants (tup variants, MR build configurations)
  Requires syntax for variables
- buildstate export to e.g. Jason or XML or to some graph format.
  Export verbose or compact.
  Verbose: references to nodes are path names
  Compact: each node has a unique id, references to nodes are ids.

Ideas:
- yam creates group hierachy of output files. Hierarchy
  mirrors the directory tree in which outputs are stored.
  E.g. outputs are a/O1, a/O2, a/b/c/O3. 
  Output groups <a> contains O1, O2 and <b>, <b> contains <c>, 
  <c> contains O3.
  yam <b>/** builds all outputs in <b> recursively. Same would happen
  for yam b/**. 
  <b>/** is kind of O(N) where N is nr of elements below <b>
  b/** is O(N), where N is nr of dirty generated file nodes in buildstate.
  yam <b>/<c>/O3 is O(N) where N is nr of elements in <b> and in <c>



More:
- implement DotIgnoreNode
- investigate use of std::filesystem::path.string() and intializing paths
  from a std::string. Shouldn't we use wstring?