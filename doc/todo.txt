Todo for R 0.1.0
Bugs
- fix (header->free == 1)  throw std::string(signature) + " - Accessing freed page.";
  Reproduce with coreTests EnduranceTest

Features
- FileNode: verify last-write-time after hashing is equal to lwt before hashing.
  If not: fail execution and set hashes to rand()
- Investigate directory links as alernative for repos
- phony rule: Inputs |>|> Group
  Example: 
       *.cpp |>|> <sources>
       foreach <sources> |> cc %f -o %o |> %B.obj
       *.obj  |>|> <objects>
       // or: foreach *.cpp |> cc %f -o %o |> %B.obj <objects>
  Yam invokation:
      yam <sources> // hash modified files when changed last-write-time
      yam <objects> // compile all dirty .obj files
      yam *.obj     // compile all dirty .obj files

  Problem: foreach <sources> is not supported by yam because files in
  group are only known after execution of its contained command nodes.
  This would require compiling the foreach after group execution.
  Possibly allow it for groups that only contain source files, generated
  files and commands with only mandatory outputs.

  Advantage: <objects> content is defined once at buildfile compile time
  (and when cpp files are added or removed) while *.obj is evaluated each 
  build again.
  Advantage: currently supported output groups requires thinking ahead of what
  groups are needed: for each rule it must be decided whether it adds outputs
  and to which groups. Changing decisions may require updates of multiple rules
  in multiple buildfiles. Phony rules can be added at any time without requiring
  changes in existing rules. Can be added in only 1 buildfile (which then must
  depend on all buildfiles that produce outputs to be added to group) but
  preferably phony rule is added to each buildfile that produce outputs to be 
  added to group.
- buildscope: current implementation only searches for the producers of dirty 
  generated file nodes. Could also search all dirty nodes to allow for example:
      yam *.cpp // hash file nodes
      yam buildfile_yam.txt // compile buildfile, or execute all commands 
                            // produced by buildfile
      yam submodules/<objects> // execute group
- integrate Phil's file access monitor
    - how to deal with input dependencies on non-existing source files
      Note: these source file nodes are NOT in state Deleted. How to GC these
      nodes when no longer refd => GC sweep over context to remove node with
      use_count 1. delete when not observed
    - directory enumeration
    - After execution (hashing) of detected input and output files: check whether
      last write times match the ones provided by access monitor. If not equal
      then fail the execution and invalidate the execution hash to force command 
      to re-execute at next build. 
- fileaspect configuration
      - hash = last-write-time (e.g. for generated files in cmd executionhash)
      - import lib exports hash (hash i/f of dll)
- response files
- xxhash stream
- build yam with yam
- deal with dependencies on gtest, boost, xxhash
  xxhash requires license to be part of binary redistribution.
- license
- C++20 modules support
  Allow commands to generated buildfiles.
  while (dirty buildfiles found) build();
- end-to-end testing (automated gtest)
- scalability measurements
- documentation
- inform Mike Shal

Out-of-scope:
- distributed build
- build cache (read MS buildXL section on caching!)
- btree/page caching
- tup-compatible syntax
- variants (tup variants, MR build configurations)
  Requires syntax for variables
- buildstate export to e.g. Jason or XML or to some graph format.
  Export verbose or compact.
  Verbose: references to nodes are path names
  Compact: each node has a unique id, references to nodes are ids.

Ideas:
- yam creates group hierachy of output files. Hierarchy
  mirrors the directory tree in which outputs are stored.
  E.g. outputs are a/O1, a/O2, a/b/c/O3. 
  Output groups <a> contains O1, O2 and <b>, <b> contains <c>, 
  <c> contains O3.
  yam <b>/** builds all outputs in <b> recursively. Same would happen
  for yam b/**. 
  <b>/** is kind of O(N) where N is nr of elements below <b>
  b/** is O(N), where N is nr of dirty generated file nodes in buildstate.
  yam <b>/<c>/O3 is O(N) where N is nr of elements in <b> and in <c>



More:
- implement DotIgnoreNode
- investigate use of std::filesystem::path.string() and intializing paths
  from a std::string. Shouldn't we use wstring?