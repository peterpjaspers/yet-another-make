Todo for R 0.1.0
Bugs
- fix (header->free == 1)  throw std::string(signature) + " - Accessing freed page.";
  Reproduce with coreTests EnduranceTest

Features
- update parser and compiler to deal with optional globs in rule output section
- CommandNode only uses the mandatory file nodes in groups to compile %-flags
- add error handling to cmd script when compiling it.

- implement glob for optional output files (dynamic outputs)
  Rule examples: 
      some/<unzipped> |> echo %f > %o |> zipTableOfContent.txt
      foreach some/<unzipped>/*.cpp |> cc %f -out %o |> %B.obj
      // Only outputs that match the glob are registered as cmd outputs.
      // All other outputs are ignored (and deleted).
      // Non-glob outputs are registered as cmd outputs.
      // All registered outputs of the rule are added to the group.
      |> unzip some1.zip |> some1_toc.txt some/* some/<unzipped>
      |> unzip some2.zip |> some/* some/<unzipped>
  The above would work fine for normal groups, i.e. groups whose content is
  defined by enumerated output paths and whose content is complete once all 
  compilations are done. It will not work however for the dynamic group because
  a) cmd outputs are unknown until the command has been executed
  b) all cmds that contribute to the group must be executed before a cmd that
     uses the group as input.
  The following design solves these issues:
      - a GroupNode can contain any type of node with special behavior for
        generated file (as currently implemented) and command nodes (new)
      - GroupNode execution executes all contained nodes. Exception: for
        generated file nodes it executes the command node that produces the
        generated file.
      - GroupNode content can be returned in 2 ways: as what was added to the 
        group and as what was added to the group with the command nodes replaced
        by their output nodes. The latter version only makes sense when the
        group has executed, i.e when its state is Ok. The former version makes
        sense after all compilation completed.
      - A GroupNode that contains CommandNode elements is a Dynamic group.
      - When compiling %B etc flags in the output section of a rule then these
        flags are applied to the elements of an input group. This does not make 
        sense for a Dynamic group because CommandNodes are not files. Either 
        ignore or treat this as an error or defer output flag compilation to 
        command node execution time (when GroupNode has executed and outputs
        of all commands in group are defined). Will implement treat-as-error.
        Same applies for %f flags in command section. But command section
        compilation is already deffered to command execution time.
         
  Note: current implementation of adding command outputs to the group can be
  replaced by just adding the command node itself to the group.
  Note: adding generated file nodes to the group is still needed to allow for
  phony rules.
  Note: an input file cannot reference a dynamic output file. Input files can
  only reference output files that are defined as paths (i.e. not as globs).
  Example (come up with a better one):
    foreach *.cpp |> cc %f -o %o |> %B.obj <objects>
    <objects> ^main.obj |> linkdll %f -out %0 |> library.lib library.dll library.*
    main.obj library.lib |> linkexe %f -out %0 |> app.exe
    library.dll |>|> <installables>
    library.
- phony rule: Inputs |>|> Group
  Example: 
       *.cpp |>|> <sources>
       foreach <sources> |> cc %f -o %o |> %B.obj
       *.obj  |>|> <objects>
       // or: foreach *.cpp |> cc %f -o %o |> %B.obj <objects>
  Yam invokation:
      yam <sources> // hash modified files when changed last-write-time
      yam <objects> // compile all dirty .obj files
      yam *.obj     // compile all dirty .obj files
  Advantage: <objects> content is defined once at buildfile compile time
  (and when cpp files are added or removed) while *.obj is evaluated each 
  build again.
  Advantage: currently supported output groups requires thinking ahead of what
  groups are needed: for each rule it must be decided whether it adds outputs
  and to which groups. Changing decisions may require updates of multiple rules
  in multiple buildfiles. Phony rules can be added at any time without requiring
  changes in existing rules. Can be added in only 1 buildfile (which then must
  depend on all buildfiles that produce outputs to be added to group) but
  preferably phony rule is added to each buildfile that produce outputs to be 
  added to group.
- buildscope: current implementation only searches for the producers of dirty 
  generated file nodes. Could also search all dirty nodes to allow for example:
      yam *.cpp // hash file nodes
      yam buildfile_yam.txt // compile buildfile, or execute all commands 
                            // produced by buildfile
      yam submodules/<objects> // execute group
- integrate Phil's file access monitor
    - how to deal with input dependencies on non-existing source files
      Note: these source file nodes are NOT in state Deleted. How to GC these
      nodes when no longer refd => GC sweep over context to remove node with
      use_count 1. delete when not observed
    - directory enumeration
- fileaspect configuration
      - hash = last-write-time (e.g. for generated files in cmd executionhash)
      - import lib exports hash (hash i/f of dll)
- response files
- xxhash stream
- build yam with yam
- deal with dependencies on gtest, boost, xxhash
  xxhash requires license to be part of binary redistribution.
- license
- C++20 modules support
  Allow commands to generated buildfiles.
  while (dirty buildfiles found) build();
- end-to-end testing (automated gtest)
- scalability measurements
- documentation
- inform Mike Shal

Out-of-scope:
- distributed build
- build cache (read MS buildXL section on caching!)
- btree/page caching
- tup-compatible syntax
- variants (tup variants, MR build configurations)
  Requires syntax for variables
- buildstate export to e.g. Jason or XML or to some graph format.
  Export verbose or compact.
  Verbose: references to nodes are path names
  Compact: each node has a unique id, references to nodes are ids.

Ideas:
- yam creates group hierachy of output files. Hierarchy
  mirrors the directory tree in which outputs are stored.
  E.g. outputs are a/O1, a/O2, a/b/c/O3. 
  Output groups <a> contains O1, O2 and <b>, <b> contains <c>, 
  <c> contains O3.
  yam <b>/** builds all outputs in <b> recursively. Same would happen
  for yam b/**. 
  <b>/** is kind of O(N) where N is nr of elements below <b>
  b/** is O(N), where N is nr of dirty generated file nodes in buildstate.
  yam <b>/<c>/O3 is O(N) where N is nr of elements in <b> and in <c>



More:
- implement DotIgnoreNode
- investigate use of std::filesystem::path.string() and intializing paths
  from a std::string. Shouldn't we use wstring?