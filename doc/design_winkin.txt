-- Winkin and winkin cache
Winkin is a build avoidance strategy that tries to re-use (winkin) files
generated by previously builds.

-- Winkin cache
Results of builds (i.e. generated files) are stored in the winkin cache.
During a build this cache is searched for re-usable files.

-- Winkin criteria (when can a file in the winkin cache be re-used)
A file G generated by a build in some worktree SRC and stored in the winkin
cache can be winked-in (re-used) from the cache by a build in worktree DST
when:
    - the build scripts to generate G in DST and SRC are equal
    - AND all input files of G in SRC exist in DST
    - AND all input files of G in SRC are identical to the ones in DST,
      i.e. the input file aspect hashes of G in SRC and DST are identical. 
Note: input files can be both source files and generated files.
Note: winkin can be implemented in various ways. The most simple one is
to copy G from winkin cache to DST worktree. Other implementations may 
create a link from DST to G in winkin cache or use a virtual file to make the
cached G visible in SRC.

-- Non-deterministic hashes cause sub-optimal winkin
A problem in dealing with generated input files is that some tools, e.g. the
Microsoft compilers and linkers, are not deterministic: running these tools 
twice on identical inputs produces outputs that are functionally identical
but not binary identical. This behavior will cause sub-optimal winkin unless
the input file aspect hashes exclude non-deterministic parts of the file.

-- Example of sub-optimal winkin due to non-deterministic hashes
Assume A.dll is linked from object file S.obj, S.obj is compiled from S.cpp, 
S.cpp is identical in SRC and DST, including equality of all (recursively) 
included header files. 
Further assume that A.dll and S.obj have been built in SRC and are stored in 
the winkin cache and that only S.obj has been built locally (i.e. not 
winked-in) in DST.
Assume that the used compiler is non-deterministic, i.e. SRC/S.obj and 
DST/S.obj are not binary identical. If the file aspect hashes do not exclude
the non-deterministic parts of the object files then the hashes of SRC/S.obj 
and DST/S.obj will be different and the winkin criteria for A.dll are not met.
Pseudo code:
    - Node::pendingStartSelf() {
            // return whether output is out-dated.
            // selfExecute is only executed when output is out-dated.
            return _executionHash != computeExecutionHash()
        }
    - selfExecute():
        if (outputFile cannot be winked-in from cache) {
            execute build script (i.e. (re-)generate outputFile)
        } else {
            copy SRC/outputFile to DST/outputFile // winkin

-- Work-around in mrmake for winkin in case of non-deterministic hashes
The problem is worked-around by mrmake's forcedWinkin option.
This option forces winkin-able files to be winked-in (copied), even when the
file was already up-to-date. 
Build logic:
    - at start of build: 
        if (forcedWinkin) {
            set all nodes in the graph rooted by A.dll to Dirty.
            // I.e. set A.dll and S.obj to Dirty.
            // Note: pendingStartSelf() is only called on Dirty nodes
        }
    - Node::pendingStartSelf() {
            return forcedWinkin || _executionHash != computeExecutionHash()
            // I.e. always selfExecute in case of forcedWinkin
        }
    - selfExecute():
        if (outputFile cannot be winked-in from cache) {
            execute build script (i.e. (re-)generate outputFile)
        } else {
            if (outputFile is not up-to-date) {
                copy SRC/outputFile to DST/outputFile // winkin
            } else if (
                forcedWinkin 
                && (hashOf(SRC/outputFile) != hashOf(DST/outputFile)
            ) {
                copy SRC/outputFile to DST/outputFile // force winkin
            }
 
Note that forcedWinkin adds build overhead because already up-to-date nodes 
are re-visited.

-- mrmake winkin versus yam winkin
mrmake winkin has some disadvantages and inconveniences:
    - the winkin cache is a worktree. So content of cache is limited to 
      the latest build in that worktre).
    - engineer must manage the cache SRC worktree, i.e. not delete it, and
      get/keep it in built state.
    - mrmake only performs winkin builds on request by engineer. Engineer has 
      to specify the SRC worktree on mrmake command line.
    - mrmake can only winkin from 1 SRC worktree at-a-time.

Ideal situation:
    - to perform winkin builds by default.
    - to winkin from build results from all builds from all worktrees from  all
      users from all (?) repositories.

Practical problems:
    - storage space is limited.
    - winkin time complexity for file G is O(N), where N is the number of 
      cached versions of G.
    - concurrent access to cache.

Possible ways to manage this:
    - only cache build results from designated worktrees/builds.
    - auto-delete cached build results that have not been re-used for a while.
    - todo: how to handle concurrency (including auto-delete use-case)?
    - todo: is it possible to reduce O(N)?
      